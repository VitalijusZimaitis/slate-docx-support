{"version":3,"file":"index.esm.js","sources":["../src/utils/traverseHtmlNode.ts","../src/constants.ts","../src/utils/preCleanHtml.ts","../src/utils/removeHtmlSurroundings.ts","../src/utils/cleanHtmlCrLf.ts","../src/index.ts","../src/utils/isDocxList.ts","../src/utils/deserializeList.ts","../src/utils/deserializeText.ts","../src/utils/traverseHtmlTexts.ts","../src/utils/cleanHtmlTextNodes.ts","../src/utils/isHtmlText.ts","../src/utils/traverseHtmlElements.ts","../src/utils/isHtmlElement.ts","../src/utils/cleanDocxListElements.ts"],"sourcesContent":["type Callback = (node: Node) => boolean;\n\n/**\n * Depth-first pre-order tree traverse the given HTML node and calls the given callback for each node.\n * see: https://en.wikipedia.org/wiki/Tree_traversal#Pre-order_(NLR)\n *\n * @param callback returns a boolean indicating whether traversal should be continued\n */\nexport const traverseHtmlNode = (node: Node, callback: Callback): void => {\n  const keepTraversing = callback(node);\n\n  if (!keepTraversing) {\n    return;\n  }\n\n  let child = node.firstChild;\n\n  while (child) {\n    const currentChild = child;\n    const previousChild = child.previousSibling;\n    child = child.nextSibling;\n\n    traverseHtmlNode(currentChild, callback);\n\n    if (\n      // An unwrap was made. Need to compute the next child again.\n      !currentChild.previousSibling &&\n      !currentChild.nextSibling &&\n      !currentChild.parentNode &&\n      child &&\n      previousChild !== child.previousSibling &&\n      child.parentNode\n    ) {\n      child = previousChild ? previousChild.nextSibling : node.firstChild;\n    } else if (\n      // A list was created. Need to compute the next child again.\n      !currentChild.previousSibling &&\n      !currentChild.nextSibling &&\n      !currentChild.parentNode &&\n      child &&\n      !child.previousSibling &&\n      !child.nextSibling &&\n      !child.parentNode\n    ) {\n      if (previousChild) {\n        child = previousChild.nextSibling\n          ? previousChild.nextSibling.nextSibling\n          : null;\n      } else if (node.firstChild) {\n        child = node.firstChild.nextSibling;\n      }\n    }\n  }\n};\n","export const CARRIAGE_RETURN = '\\u000D';\nexport const LINE_FEED = '\\u000A';\nexport const NO_BREAK_SPACE = '\\u00A0';\nexport const SPACE = '\\u0020';\nexport const TAB = '\\u0009';\nexport const ZERO_WIDTH_SPACE = '\\u200B';\n","import { cleanHtmlCrLf } from './cleanHtmlCrLf';\nimport { removeHtmlSurroundings } from './removeHtmlSurroundings';\n\nconst cleaners = [removeHtmlSurroundings, cleanHtmlCrLf];\n\n/**\n * Remove HTML surroundings and clean HTML from CR/LF\n */\nexport const preCleanHtml = (html: string): string => {\n  return cleaners.reduce((result, clean) => clean(result), html);\n};\n","/**\n * Remove string before <html\n */\nconst removeBeforeHtml = (html: string): string => {\n  const index = html.indexOf('<html');\n  if (index === -1) {\n    return html;\n  }\n  return html.slice(Math.max(0, index));\n};\n\n/**\n * Remove string after </html>\n */\nconst removeAfterHtml = (html: string): string => {\n  const index = html.lastIndexOf('</html>');\n  if (index === -1) {\n    return html;\n  }\n  return html.slice(0, Math.max(0, index + '</html>'.length));\n};\n\n/**\n * Remove string before <html and after </html>\n */\nexport const removeHtmlSurroundings = (html: string): string => {\n  return removeBeforeHtml(removeAfterHtml(html));\n};\n","/**\n * Replace \\r\\n and \\r with \\n\n */\nexport const cleanHtmlCrLf = (html: string): string => {\n  return html.replaceAll(/(\\r\\n|\\r)/g, '\\n');\n};\n","import { jsx } from \"slate-hyperscript\";\n\nimport { cleanDocxListElements } from \"./utils/cleanDocxListElements\";\nimport { cleanHtmlTextNodes } from \"./utils/cleanHtmlTextNodes\";\nimport { deserializeList } from \"./utils/deserializeList\";\nimport { deserializeText } from \"./utils/deserializeText\";\nimport { isDocxList } from \"./utils/isDocxList\";\nimport { preCleanHtml } from \"./utils/preCleanHtml\";\n\nexport const deserialize = (el: Element, markAttributes = {}) => {\n    if (el.nodeType === Node.TEXT_NODE) {\n        return jsx(\"text\", markAttributes, el.textContent);\n    } else if (el.nodeType !== Node.ELEMENT_NODE) {\n        return null;\n    }\n\n    // Removes all elements with the class \"done\" that is added to already serialized elements\n    if (\n        el.attributes &&\n        el.attributes.getNamedItem(\"class\") &&\n        el.attributes.getNamedItem(\"class\")?.value.match(/done/g)\n    ) {\n        return null;\n    }\n\n    const nodeAttributes: Record<string, boolean> = { ...markAttributes };\n\n    // define attributes for text nodes\n    switch (el.nodeName) {\n        case \"B\":\n            nodeAttributes.bold = true;\n            break;\n\n        case \"I\":\n            nodeAttributes.italic = true;\n            break;\n\n        case \"U\":\n            nodeAttributes.underline = true;\n            break;\n\n        case \"STRIKE\":\n            nodeAttributes.strikethrough = true;\n            break;\n    }\n\n    const children = Array.from(el.childNodes)\n        .map(node => deserialize(node as Element, nodeAttributes))\n        .flat();\n\n    if (children.length === 0) {\n        children.push(jsx(\"text\", nodeAttributes, \"\"));\n    }\n\n    if (isDocxList(el)) {\n        const list = deserializeList(el);\n\n        return deserialize(list, nodeAttributes);\n    }\n\n    return deserializeText(el, children);\n};\n\nexport const withDocxDeserializer = (editor: any) => {\n    const { insertData, isInline, isVoid, insertFragment } = editor;\n\n    editor.insertFragment = element => {\n        insertFragment(element);\n    };\n\n    editor.isInline = element => {\n        return element.type === \"link\" ? true : isInline(element);\n    };\n\n    editor.isVoid = element => {\n        return element.type === \"image\" ? true : isVoid(element);\n    };\n\n    editor.insertData = data => {\n        const html = data.getData(\"text/html\");\n\n        if (html) {\n            const document = new DOMParser().parseFromString(\n                preCleanHtml(html),\n                \"text/html\"\n            );\n\n            const { body } = document;\n\n            cleanHtmlTextNodes(body);\n            cleanDocxListElements(body);\n\n            const fragment = deserialize(document.body);\n            return editor.insertFragment(fragment);\n        }\n\n        insertData(data);\n    };\n    return editor;\n};\n","export const isDocxList = (element: Element): boolean => {\n  const styleAttribute = element.getAttribute('style');\n\n  if (!styleAttribute) {\n    return false;\n  }\n\n  const hasMsoListInStyle = /mso-list:\\s*l/i.test(styleAttribute);\n\n  if (!hasMsoListInStyle) {\n    return false;\n  }\n\n  const hasMsoListIgnoreChild = Boolean(\n    element.querySelector('[style=\"mso-list:Ignore\"]')\n  );\n\n  if (hasMsoListIgnoreChild) {\n    return true;\n  }\n\n  return element.outerHTML.includes('<!--[if !supportLists]-->');\n};\n","// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-nocheck\n\nexport const getSiblings = (el: Element) => {\n    const siblings = [];\n    while (\n        el &&\n        el.attributes.getNamedItem(\"class\") &&\n        el.attributes.getNamedItem(\"class\")?.value.match(/MsoListParagraph/g)\n    ) {\n        const level = el.attributes\n            ?.getNamedItem(\"style\")\n            ?.value.match(/level(\\d+)/)?.[1];\n        el.setAttribute(\"class\", \"done\"); // we set this attribute to avoid getting stuck in an infinite loop\n        el.setAttribute(\"style\", level ?? \"1\");\n        siblings.push(el);\n        if (el) {\n            el = el.nextElementSibling as Element;\n        }\n    }\n\n    return siblings;\n};\n\nexport const getListType = (el: Element) => {\n    const val = el.textContent[0];\n    const regex = /^\\d+$/;\n    return regex.test(val) ? \"OL\" : \"UL\";\n};\n\nexport const getTextFromList = (el: Element) => {\n    const children = Array.from(el.childNodes);\n    const result = [];\n    result.push(childred[children.length - 1]);\n    return result;\n};\n\nexport const deserializeList = (el: Element) => {\n    const siblings = getSiblings(el);\n    const type = getListType(el);\n    const list_wrapper = document.createElement(type);\n    for (let i = 0; i < siblings.length; i++) {\n        const listElement = document.createElement(\"li\");\n        const sibling = siblings[i].innerText.replace(/[^a-zA-Z ]/g, \"\");\n        siblings[i].classList.add(\"done\");\n        listElement.append(sibling);\n        list_wrapper.appendChild(listElement);\n    }\n\n    return list_wrapper;\n};\n","import { jsx } from \"slate-hyperscript\";\n\nexport const deserializeText = (el: Element, children: Element) => {\n    switch (el.nodeName) {\n        case \"BODY\":\n            return jsx(\"fragment\", {}, children);\n        case \"SPAN\":\n            return jsx(\"fragment\", {}, children);\n        case \"o:p\":\n            return jsx(\"fragment\", {}, children);\n        case \"BR\":\n            return \"\\n\";\n        case \"BLOCKQUOTE\":\n            return jsx(\"element\", { type: \"quote\" }, children);\n        case \"P\":\n            return jsx(\"element\", { type: \"paragraph\" }, children);\n        case \"UL\":\n            return jsx(\"element\", { type: \"bulleted-list\" }, children);\n        case \"OL\":\n            return jsx(\"element\", { type: \"numbered-list\" }, children);\n        case \"LI\":\n            return jsx(\"element\", { type: \"list-item\" }, children);\n        case \"A\":\n            return jsx(\n                \"element\",\n                { type: \"link\", url: el.getAttribute(\"href\") },\n                children\n            );\n        default:\n            return children;\n    }\n};\n","import { isHtmlText } from './isHtmlText';\nimport { traverseHtmlNode } from './traverseHtmlNode';\n\ntype Callback = (node: Text) => boolean;\n\nexport const traverseHtmlTexts = (rootNode: Node, callback: Callback): void => {\n  traverseHtmlNode(rootNode, (node) => {\n    if (!isHtmlText(node)) {\n      return true;\n    }\n\n    return callback(node);\n  });\n};\n","import { traverseHtmlTexts } from \"./traverseHtmlTexts\";\nimport {\n    CARRIAGE_RETURN,\n    LINE_FEED,\n    NO_BREAK_SPACE,\n    SPACE,\n} from \"../constants\";\n\nexport const cleanHtmlTextNodes = (rootNode: Node): void => {\n    traverseHtmlTexts(rootNode, textNode => {\n        if (\n            /^\\n\\s*$/.test(textNode.data) &&\n            (textNode.previousElementSibling || textNode.nextElementSibling)\n        ) {\n            textNode.remove();\n\n            return true;\n        }\n\n        textNode.data = textNode.data.replaceAll(/\\n\\s*/g, \"\\n\");\n\n        if (\n            textNode.data.includes(CARRIAGE_RETURN) ||\n            textNode.data.includes(LINE_FEED) ||\n            textNode.data.includes(NO_BREAK_SPACE)\n        ) {\n            const hasSpace = textNode.data.includes(SPACE);\n            const hasNonWhitespace = /\\S/.test(textNode.data);\n            const hasLineFeed = textNode.data.includes(LINE_FEED);\n\n            if (!(hasSpace || hasNonWhitespace) && !hasLineFeed) {\n                if (textNode.data === NO_BREAK_SPACE) {\n                    textNode.data = SPACE;\n                    return true;\n                }\n\n                textNode.remove();\n\n                return true;\n            }\n\n            if (\n                textNode.previousSibling &&\n                textNode.previousSibling.nodeName === \"BR\" &&\n                textNode.parentElement\n            ) {\n                textNode.previousSibling.remove();\n\n                const matches = textNode.data.match(/^[\\n\\r]+/);\n                const offset = matches ? matches[0].length : 0;\n\n                textNode.data = textNode.data\n                    .slice(Math.max(0, offset))\n                    .replaceAll(new RegExp(LINE_FEED, \"g\"), SPACE)\n                    .replaceAll(new RegExp(CARRIAGE_RETURN, \"g\"), SPACE);\n                textNode.data = `\\n${textNode.data}`;\n            } else {\n                textNode.data = textNode.data\n                    .replaceAll(new RegExp(LINE_FEED, \"g\"), SPACE)\n                    .replaceAll(new RegExp(CARRIAGE_RETURN, \"g\"), SPACE);\n            }\n        }\n\n        return true;\n    });\n};\n","export const isHtmlText = (node: Node): node is Text =>\n  node.nodeType === Node.TEXT_NODE;\n","import { isHtmlElement } from './isHtmlElement';\nimport { traverseHtmlNode } from './traverseHtmlNode';\n\ntype Callback = (node: Element) => boolean;\n\n/**\n * Traverse the HTML elements of the given HTML node.\n * @param rootNode The root HTML node to traverse.\n * @param callback The callback to call for each HTML element.\n */\nexport const traverseHtmlElements = (\n  rootNode: Node,\n  callback: Callback\n): void => {\n  traverseHtmlNode(rootNode, (node) => {\n    if (!isHtmlElement(node)) {\n      return true;\n    }\n\n    return callback(node);\n  });\n};\n","export const isHtmlElement = (node: Node): node is Element =>\n  node.nodeType === Node.ELEMENT_NODE;\n","import { traverseHtmlElements } from \"./traverseHtmlElements\";\n\n/**\n * Clean elements style mso-list to mso-list:Ignore\n */\nexport const cleanDocxListElements = (rootNode: Node): void => {\n    traverseHtmlElements(rootNode, element => {\n        const styleAttribute = element.getAttribute(\"style\");\n\n        if (styleAttribute) {\n            element.setAttribute(\n                \"style\",\n                styleAttribute.replaceAll(\n                    /mso-list:\\s*ignore/gi,\n                    \"mso-list:Ignore\"\n                )\n            );\n        }\n\n        return true;\n    });\n};\n"],"names":["traverseHtmlNode","node","callback","child","firstChild","currentChild","previousChild","previousSibling","nextSibling","parentNode","LINE_FEED","SPACE","cleaners","html","index","indexOf","slice","Math","max","removeBeforeHtml","lastIndexOf","removeAfterHtml","replaceAll","deserialize","el","markAttributes","_el$attributes$getNam","nodeType","Node","TEXT_NODE","jsx","textContent","ELEMENT_NODE","attributes","getNamedItem","value","match","nodeAttributes","_extends","nodeName","bold","italic","underline","strikethrough","element","styleAttribute","children","Array","from","childNodes","map","flat","length","push","getAttribute","test","Boolean","querySelector","outerHTML","includes","list","siblings","_el$attributes","level","setAttribute","nextElementSibling","getSiblings","type","getListType","list_wrapper","document","createElement","i","listElement","sibling","innerText","replace","classList","add","append","appendChild","deserializeList","url","deserializeText","withDocxDeserializer","editor","insertData","isInline","isVoid","insertFragment","data","getData","DOMParser","parseFromString","reduce","result","clean","preCleanHtml","body","textNode","previousElementSibling","remove","hasSpace","hasNonWhitespace","hasLineFeed","parentElement","matches","RegExp","isHtmlText","isHtmlElement","fragment"],"mappings":"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"}