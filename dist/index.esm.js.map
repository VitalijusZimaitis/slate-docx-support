{"version":3,"file":"index.esm.js","sources":["../src/utils.js","../src/native.js","../src/index.ts","../src/module.js"],"sourcesContent":["import * as blobUtil from 'blob-util'\n\n// Receives rtf and html data\n// Returns dictionary object of original img[src]:imgBlob\n// We must read the data from the rtf because the browser is not allowed to render pasted images using simply the src from your clipboard\nexport const imagePastingListener = (rtf, html) => {\n  const ret = {}\n  const imgTags = extractTagsFromHtml(html)\n  const newSrcValues = []\n\n  const hexImages = extractFromRtf(rtf)\n  if (hexImages.length === 0) {\n    return\n  }\n\n  for (let i = 0; i < hexImages.length; i++) {\n    const base64string = createSrcWithBase64(hexImages[i])\n    const blob = blobUtil.base64StringToBlob(base64string)\n    const URLObj = window.URL || window.webkitURL\n    const url = URLObj.createObjectURL(blob)\n    newSrcValues.push(url)\n  }\n\n  if (imgTags.length === newSrcValues.length) {\n    for (let i = 0; i < imgTags.length; i++) {\n      // Replace only `file` urls of images ( shapes get newSrcValue with null ).\n      if (imgTags[i].indexOf('file://') === 0 && newSrcValues[i]) {\n        ret[imgTags[i]] = newSrcValues[i]\n      }\n    }\n  }\n\n  return ret\n}\n\nconst extractFromRtf = rtfContent => {\n  const ret = []\n  const rePictureHeader = /\\{\\\\pict[\\s\\S]+?\\\\bliptag\\-?\\d+(\\\\blipupi\\-?\\d+)?(\\{\\\\\\*\\\\blipuid\\s?[\\da-fA-F]+)?[\\s\\}]*?/\n  const rePicture = new RegExp(\n    `(?:(${rePictureHeader.source}))([\\\\da-fA-F\\\\s]+)\\\\}`,\n    'g'\n  )\n  let imageType = ''\n\n  const wholeImages = rtfContent.match(rePicture)\n  if (!wholeImages) {\n    return ret\n  }\n\n  for (let i = 0; i < wholeImages.length; i++) {\n    if (rePictureHeader.test(wholeImages[i])) {\n      if (wholeImages[i].indexOf('\\\\pngblip') !== -1) {\n        imageType = 'image/png'\n      } else if (wholeImages[i].indexOf('\\\\jpegblip') !== -1) {\n        imageType = 'image/jpeg'\n      } else {\n        continue\n      }\n\n      ret.push({\n        hex: imageType\n          ? wholeImages[i]\n            .replace(rePictureHeader, '')\n            .replace(/[^\\da-fA-F]/g, '')\n          : null,\n        type: imageType,\n      })\n    }\n  }\n\n  return ret\n}\n\nexport const extractTagsFromHtml = html => {\n  const regexp = /<img[^>]+src=\"([^\"]+)[^>]+/g\n  const ret = []\n  let item\n\n  while ((item = regexp.exec(html))) {\n    ret.push(item[1])\n  }\n\n  return ret\n}\n\nconst convertHexStringToBytes = hexString => {\n  const bytesArray = []\n  const bytesArrayLength = hexString.length / 2\n  let i\n\n  for (i = 0; i < bytesArrayLength; i++) {\n    bytesArray.push(parseInt(hexString.substr(i * 2, 2), 16))\n  }\n  return bytesArray\n}\n\nfunction createSrcWithBase64(img) {\n  const ret = null\n  return convertBytesToBase64(convertHexStringToBytes(img.hex))\n}\n\nconst convertBytesToBase64 = bytesArray => {\n  // Bytes are `8bit` numbers, where base64 use `6bit` to store data. That's why we process 3 Bytes into 4 characters representing base64.\n  //\n  // Algorithm:\n  // 1. Take `3 * 8bit`.\n  // 2. If there is less than 3 bytes, fill empty bits with zeros.\n  // 3. Transform `3 * 8bit` into `4 * 6bit` numbers.\n  // 4. Translate those numbers to proper characters related to base64.\n  // 5. If extra zero bytes were added fill them with `=` sign.\n  //\n  // Example:\n  // 1. Bytes Array: [ 8, 161, 29, 138, 218, 43 ] -> binary: `0000 1000 1010 0001 0001 1101 1000 1010 1101 1010 0010 1011`.\n  // 2. Binary: `0000 10|00 1010| 0001 00|01 1101| 1000 10|10 1101| 1010 00|10 1011` ← `|` (pipe) shows where base64 will cut bits during transformation.\n  // 3. Now we have 6bit numbers (written in decimal values), which are translated to indexes in `base64characters` array.\n  //    Decimal: `2 10 4 29 34 45 40 43` → base64: `CKEditor`.\n  const base64characters =\n    'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\n  let base64string = ''\n  const bytesArrayLength = bytesArray.length\n  let i\n\n  for (i = 0; i < bytesArrayLength; i += 3) {\n    const array3 = bytesArray.slice(i, i + 3)\n    const array3length = array3.length\n    const array4 = []\n\n    if (array3length < 3) {\n      for (let j = array3length; j < 3; j++) {\n        array3[j] = 0\n      }\n    }\n\n    // 0xFC -> 11111100 || 0x03 -> 00000011 || 0x0F -> 00001111 || 0xC0 -> 11000000 || 0x3F -> 00111111\n    array4[0] = (array3[0] & 0xfc) >> 2\n    array4[1] = ((array3[0] & 0x03) << 4) | (array3[1] >> 4)\n    array4[2] = ((array3[1] & 0x0f) << 2) | ((array3[2] & 0xc0) >> 6)\n    array4[3] = array3[2] & 0x3f\n\n    for (let j = 0; j < 4; j++) {\n      // Example: if array3length == 1, then we need to add 2 equal signs at the end of base64.\n      // array3[ 0 ] is used to calculate array4[ 0 ] and array4[ 1 ], so there will be regular values,\n      // next two ones have to be replaced with `=`, because array3[ 1 ] and array3[ 2 ] wasn't present in the input string.\n      if (j <= array3length) {\n        base64string += base64characters.charAt(array4[j])\n      } else {\n        base64string += '='\n      }\n    }\n  }\n  return base64string\n}\n","// Element and Text Tags Definitions\n\nexport const ELEMENT_TAGS = {\n  A: el => ({ type: 'link', url: el.getAttribute('href') }),\n  BLOCKQUOTE: () => ({ type: 'quote' }),\n  H1: () => ({ type: 'heading-one' }),\n  H2: () => ({ type: 'heading-two' }),\n  H3: () => ({ type: 'heading-three' }),\n  H4: () => ({ type: 'heading-four' }),\n  H5: () => ({ type: 'heading-five' }),\n  H6: () => ({ type: 'heading-six' }),\n  IMG: el => ({ type: 'image', url: el.getAttribute('src') }),\n  LI: el => ({ type: 'list-item' }),\n  OL: () => ({ type: 'numbered-list' }),\n  P: () => ({ type: 'paragraph' }),\n  PRE: () => ({ type: 'code' }),\n  UL: () => ({ type: 'bulleted-list' }),\n  TABLE: () => ({ type: 'table' }),\n  TR: () => ({ type: 'table-row' }),\n  TD: () => ({ type: 'table-cell' }),\n}\n\nexport const TEXT_TAGS = {\n  CODE: () => ({ code: true }),\n  DEL: () => ({ strikethrough: true }),\n  EM: () => ({ italic: true }),\n  I: () => ({ italic: true }),\n  S: () => ({ strikethrough: true }),\n  B: () => ({ bold: true }),\n  U: () => ({ underline: true }),\n}\n","import { imagePastingListener } from './utils';\nimport { makeDeserializer } from './module';\n\nexport const withDocxDeserializer = (editor, jsx) => {\n    const { insertData, isInline, isVoid, insertFragment } = editor\n    const deserialize = makeDeserializer(jsx)\n\n\n    editor.insertFragment = element => {\n        insertFragment(element)\n    }\n\n    editor.isInline = element => {\n        return element.type === 'link' ? true : isInline(element)\n    }\n\n    editor.isVoid = element => {\n        return element.type === 'image' ? true : isVoid(element)\n    }\n\n    editor.insertData = data => {\n        const html = data.getData('text/html')\n        const rtf = data.getData('text/rtf')\n        // image tags have to be cleaned out and converted\n        const imageTags = imagePastingListener(rtf, html)\n\n        if (html) {\n            const parsed_html = new DOMParser().parseFromString(html, 'text/html')\n            const fragment = deserialize(parsed_html.body, imageTags)\n            editor.insertFragment(fragment)\n            return\n        }\n\n        insertData(data)\n    }\n    return editor\n}\n","import { ELEMENT_TAGS, TEXT_TAGS } from './native';\n\nimport './styles.css';\n\nexport const makeDeserializer = (jsx) => {\n  const deserialize = (el, imageTags) => {\n    if (\n      el.attributes &&\n      el.attributes.getNamedItem('class') &&\n      el.attributes.getNamedItem('class').value.match(/done/g)\n    ) {\n      return null\n    }\n\n    if (isList(el)) {\n      return deserializeList(el, imageTags)\n    }\n    return deserializeElement(el, imageTags)\n  }\n\n  function deserializeList(el, imageTags) {\n    const siblings = getSiblings(el)\n    console.log(el);\n    const type = 'UL'\n    const list_wrapper = document.createElement(type)\n    for (let i = 0; i < siblings.length; i++) {\n      list_wrapper.appendChild(siblings[i])\n    }\n\n    const attrs = ELEMENT_TAGS[type](list_wrapper)\n    const children = Array.from(list_wrapper.childNodes)\n      .map(child => {\n        return deserializeListItem(child, imageTags)\n      })\n      .flat()\n\n    return jsx('element', attrs, children)\n  }\n  function deserializeElement(el, imageTags) {\n    if (el.nodeType === 3) {\n      if (el.parentNode.nodeName === 'O:P') {\n        if (el.parentNode.parentNode.nodeName === 'P') {\n          return el.textContent\n        }\n      }\n\n      if (el.textContent.match(/^[\\s]*$/gm)) {\n        return null\n      } else {\n        // sometimes work adds line breaks when pasting\n        const regex = /\\n(?!\\n)/g\n        el.textContent = el.textContent.replace(regex, ' ')\n        return el.textContent\n      }\n    } else if (el.nodeType !== 1) {\n      return null\n    } else if (el.nodeName === 'BR') {\n      return '\\n'\n    }\n\n    const { nodeName } = el\n\n    let parent = el\n\n    if (\n      nodeName === 'PRE' &&\n      el.childNodes[0] &&\n      el.childNodes[0].nodeName === 'CODE'\n    ) {\n      parent = el.childNodes[0]\n    }\n\n    let children = Array.from(parent.childNodes)\n      .map(child => {\n        return deserialize(child, imageTags)\n      })\n      .flat()\n\n    if (el.nodeName === 'BODY') {\n      const filler = jsx('element', { type: 'p', className: 'P' }, [\n        { text: ' ' },\n      ])\n      children.unshift(filler)\n      return jsx('fragment', {}, children)\n    }\n\n    if (ELEMENT_TAGS[nodeName]) {\n      if (nodeName === 'IMG') {\n        const src = el.getAttribute('src')\n        if (imageTags[src]) {\n          el.setAttribute('src', imageTags[src])\n          children = []\n        }\n        const attrs = ELEMENT_TAGS[nodeName](el)\n        return jsx('element', attrs, children)\n      }\n      if (nodeName === 'H3' || nodeName === 'H2' || nodeName === 'H1') {\n        return jsx('element', { type: nodeName, className: nodeName }, children)\n      }\n      const attrs = ELEMENT_TAGS[nodeName](el)\n      return jsx('element', attrs, children)\n    }\n\n    if (TEXT_TAGS[nodeName]) {\n      const attrs = TEXT_TAGS[nodeName](el)\n      return children.map(child => jsx('text', attrs, child))\n    }\n\n    return children\n  }\n\n  function deserializeListItem(el, imageTags) {\n    const level = el.getAttribute('style')\n    const content = getTextfromList(el)\n      .map(c => {\n        return deserializeElement(c, imageTags)\n      })\n      .flat()\n    return jsx(\n      'element',\n      { type: 'list-item', className: 'level'.concat(level) },\n      content\n    )\n  }\n\n  return deserialize\n\n}\n\n\n\n// gets ALL the\nfunction getSiblings(el) {\n  // const level = el.attributes.getNamedItem('style').value.match(/level(\\d+)/)[1]\n  const siblings = []\n  while (\n    el &&\n    el.attributes.getNamedItem('class') &&\n    el.attributes.getNamedItem('class').value.match(/MsoListParagraph/g)\n  ) {\n    const level = el.attributes\n      .getNamedItem('style')\n      .value.match(/level(\\d+)/)[1]\n    el.setAttribute('class', 'done') // we set this attribute to avoid getting stuck in an infinite loop\n    el.setAttribute('style', level)\n    siblings.push(el)\n    el = el.nextElementSibling\n  }\n\n  return siblings\n}\n\n// Docx lists begin with \"MsoListParagraph\".\nfunction isList(el) {\n  if (\n    el.attributes &&\n    el.attributes.getNamedItem('class') &&\n    el.attributes.getNamedItem('class').value.match(/MsoListParagraph/g)\n  ) {\n    return true\n  }\n  return false\n}\n\n// Future functionality: Ordered Lists\nfunction isOrderedList(el) {\n  const val = el.textContent[0]\n  const regex = /^\\d+$/\n  if (regex.test(val)) {\n    return true\n  }\n  return false\n}\n\n\n// receives a list item and returns the text inside it\n// sometimes the text will be inside a text tag or inside a span tag.\n// when it is inside a text tag, the span is irrelevant, but it contains empty text inside\nfunction getTextfromList(el) {\n  const children = Array.from(el.childNodes)\n  const result = []\n  children.map(child => {\n    if (TEXT_TAGS[child.nodeName] || child.nodeName === '#text') {\n      result.push(child)\n    } else if (child.nodeName === 'SPAN') {\n      child.textContent = child.textContent.replace(\n        /(^(\\W)(?=\\s)*)|(o\\s)(?!\\w)/gm,\n        ''\n      )\n      result.push(child)\n    }\n  })\n  return result\n}\n"],"names":["convertHexStringToBytes","hexString","i","bytesArray","bytesArrayLength","length","push","parseInt","substr","convertBytesToBase64","base64string","array3","slice","array3length","array4","j","charAt","ELEMENT_TAGS","A","el","type","url","getAttribute","BLOCKQUOTE","H1","H2","H3","H4","H5","H6","IMG","LI","OL","P","PRE","UL","TABLE","TR","TD","TEXT_TAGS","CODE","code","DEL","strikethrough","EM","italic","I","S","B","bold","U","underline","withDocxDeserializer","editor","jsx","insertData","isInline","isVoid","insertFragment","deserialize","imageTags","attributes","getNamedItem","value","match","isList","siblings","level","setAttribute","nextElementSibling","getSiblings","console","log","list_wrapper","document","createElement","appendChild","attrs","children","Array","from","childNodes","map","child","content","result","nodeName","textContent","replace","getTextfromList","c","deserializeElement","flat","className","concat","deserializeListItem","deserializeList","nodeType","parentNode","parent","filler","text","unshift","src","makeDeserializer","element","data","html","getData","rtf","ret","imgTags","item","regexp","exec","extractTagsFromHtml","newSrcValues","hexImages","rtfContent","rePictureHeader","rePicture","RegExp","source","imageType","wholeImages","test","indexOf","hex","extractFromRtf","blob","blobUtil","base64StringToBlob","window","URL","webkitURL","createObjectURL","imagePastingListener","parsed_html","DOMParser","parseFromString","fragment","body"],"mappings":"4BAKa,IAgFPA,EAA0B,SAAAC,GAC9B,IAEIC,EAFEC,EAAa,GACbC,EAAmBH,EAAUI,OAAS,EAG5C,IAAKH,EAAI,EAAGA,EAAIE,EAAkBF,IAChCC,EAAWG,KAAKC,SAASN,EAAUO,OAAW,EAAJN,EAAO,GAAI,KAEvD,OAAOC,CACT,EAOMM,EAAuB,SAAAN,GAe3B,IAIID,EAFAQ,EAAe,GACbN,EAAmBD,EAAWE,OAGpC,IAAKH,EAAI,EAAGA,EAAIE,EAAkBF,GAAK,EAAG,CACxC,IAAMS,EAASR,EAAWS,MAAMV,EAAGA,EAAI,GACjCW,EAAeF,EAAON,OACtBS,EAAS,GAEf,GAAID,EAAe,EACjB,IAAK,IAAIE,EAAIF,EAAcE,EAAI,EAAGA,IAChCJ,EAAOI,GAAK,EAKhBD,EAAO,IAAkB,IAAZH,EAAO,KAAc,EAClCG,EAAO,IAAmB,EAAZH,EAAO,KAAc,EAAMA,EAAO,IAAM,EACtDG,EAAO,IAAmB,GAAZH,EAAO,KAAc,GAAmB,IAAZA,EAAO,KAAc,EAC/DG,EAAO,GAAiB,GAAZH,EAAO,GAEnB,IAAK,IAAII,EAAI,EAAGA,EAAI,EAAGA,IAKnBL,GADEK,GAAKF,EA1BX,mEA2BqCG,OAAOF,EAAOC,IAE/B,GAGtB,CACA,OAAOL,CACT,ECrJaO,EAAe,CAC1BC,EAAG,SAAAC,SAAO,CAAEC,KAAM,OAAQC,IAAKF,EAAGG,aAAa,QAAS,EACxDC,WAAY,WAAO,MAAA,CAAEH,KAAM,QAAS,EACpCI,GAAI,WAAO,MAAA,CAAEJ,KAAM,cAAe,EAClCK,GAAI,iBAAO,CAAEL,KAAM,cAAe,EAClCM,GAAI,WAAA,MAAO,CAAEN,KAAM,gBAAiB,EACpCO,GAAI,WAAO,MAAA,CAAEP,KAAM,eAAgB,EACnCQ,GAAI,iBAAO,CAAER,KAAM,eAAgB,EACnCS,GAAI,WAAA,MAAO,CAAET,KAAM,cAAe,EAClCU,IAAK,SAAAX,SAAO,CAAEC,KAAM,QAASC,IAAKF,EAAGG,aAAa,OAAQ,EAC1DS,GAAI,SAAAZ,GAAE,MAAK,CAAEC,KAAM,YAAa,EAChCY,GAAI,WAAA,MAAO,CAAEZ,KAAM,gBAAiB,EACpCa,EAAG,iBAAO,CAAEb,KAAM,YAAa,EAC/Bc,IAAK,WAAA,MAAO,CAAEd,KAAM,OAAQ,EAC5Be,GAAI,WAAA,MAAO,CAAEf,KAAM,gBAAiB,EACpCgB,MAAO,WAAO,MAAA,CAAEhB,KAAM,QAAS,EAC/BiB,GAAI,WAAO,MAAA,CAAEjB,KAAM,YAAa,EAChCkB,GAAI,iBAAO,CAAElB,KAAM,aAAc,GAGtBmB,EAAY,CACvBC,KAAM,WAAO,MAAA,CAAEC,MAAM,EAAM,EAC3BC,IAAK,iBAAO,CAAEC,eAAe,EAAM,EACnCC,GAAI,WAAA,MAAO,CAAEC,QAAQ,EAAM,EAC3BC,EAAG,WAAA,MAAO,CAAED,QAAQ,EAAM,EAC1BE,EAAG,WAAO,MAAA,CAAEJ,eAAe,EAAM,EACjCK,EAAG,WAAO,MAAA,CAAEC,MAAM,EAAM,EACxBC,EAAG,iBAAO,CAAEC,WAAW,EAAM,GC1BlBC,EAAuB,SAACC,EAAQC,GACzC,IAAQC,EAAiDF,EAAjDE,WAAYC,EAAqCH,EAArCG,SAAUC,EAA2BJ,EAA3BI,OAAQC,EAAmBL,EAAnBK,eAChCC,ECDsB,SAACL,GAC/B,IAAMK,EAAc,SAACxC,EAAIyC,GACvB,OACEzC,EAAG0C,YACH1C,EAAG0C,WAAWC,aAAa,UAC3B3C,EAAG0C,WAAWC,aAAa,SAASC,MAAMC,MAAM,SAEzC,KA8Ib,SAAgB7C,GACd,SACEA,EAAG0C,YACH1C,EAAG0C,WAAWC,aAAa,UAC3B3C,EAAG0C,WAAWC,aAAa,SAASC,MAAMC,MAAM,qBAKpD,CApJQC,CAAO9C,GAMb,SAAyBA,EAAIyC,GAC3B,IAAMM,EA+GV,SAAqB/C,GAGnB,IADA,IAAM+C,EAAW,GAEf/C,GACAA,EAAG0C,WAAWC,aAAa,UAC3B3C,EAAG0C,WAAWC,aAAa,SAASC,MAAMC,MAAM,sBAChD,CACA,IAAMG,EAAQhD,EAAG0C,WACdC,aAAa,SACbC,MAAMC,MAAM,cAAc,GAC7B7C,EAAGiD,aAAa,QAAS,QACzBjD,EAAGiD,aAAa,QAASD,GACzBD,EAAS5D,KAAKa,GACdA,EAAKA,EAAGkD,kBACV,CAEA,OAAOH,CACT,CAjIqBI,CAAYnD,GAC7BoD,QAAQC,IAAIrD,GAGZ,IAFA,IACMsD,EAAeC,SAASC,cADjB,MAEJzE,EAAI,EAAGA,EAAIgE,EAAS7D,OAAQH,IACnCuE,EAAaG,YAAYV,EAAShE,IAGpC,IAAM2E,EAAQ5D,EAAiB,GAAEwD,GAC3BK,EAAWC,MAAMC,KAAKP,EAAaQ,YACtCC,IAAI,SAAAC,GACH,OA+EN,SAA6BhE,EAAIyC,GAC/B,IAAMO,EAAQhD,EAAGG,aAAa,SACxB8D,EAiEV,SAAyBjE,GACvB,IAAM2D,EAAWC,MAAMC,KAAK7D,EAAG8D,YACzBI,EAAS,GAYf,OAXAP,EAASI,IAAI,SAAAC,GACP5C,EAAU4C,EAAMG,WAAgC,UAAnBH,EAAMG,SACrCD,EAAO/E,KAAK6E,GACgB,SAAnBA,EAAMG,WACfH,EAAMI,YAAcJ,EAAMI,YAAYC,QACpC,+BACA,IAEFH,EAAO/E,KAAK6E,GAEhB,GACOE,CACT,CAhFoBI,CAAgBtE,GAC7B+D,IAAI,SAAAQ,GACH,OAAOC,EAAmBD,EAAG9B,EAC/B,GACCgC,OACH,OAAOtC,EACL,UACA,CAAElC,KAAM,YAAayE,UAAW,QAAQC,OAAO3B,IAC/CiB,EAEJ,CA3FaW,CAAoBZ,EAAOvB,EACpC,GACCgC,OAEH,OAAOtC,EAAI,UAAWuB,EAAOC,EAC/B,CAtBWkB,CAAgB7E,EAAIyC,GAEtB+B,EAAmBxE,EAAIyC,EAChC,EAoBA,SAAS+B,EAAmBxE,EAAIyC,GAC9B,GAAoB,IAAhBzC,EAAG8E,SACL,MAA+B,QAA3B9E,EAAG+E,WAAWZ,UAC0B,MAAtCnE,EAAG+E,WAAWA,WAAWZ,SACpBnE,EAAGoE,YAIVpE,EAAGoE,YAAYvB,MAAM,mBAKvB7C,EAAGoE,YAAcpE,EAAGoE,YAAYC,QADlB,YACiC,KACxCrE,EAAGoE,aAEP,GAAoB,IAAhBpE,EAAG8E,SACZ,OACF,KAAO,GAAoB,OAAhB9E,EAAGmE,SACZ,MAAO,KAGT,IAAQA,EAAanE,EAAbmE,SAEJa,EAAShF,EAGE,QAAbmE,GACAnE,EAAG8D,WAAW,IACgB,SAA9B9D,EAAG8D,WAAW,GAAGK,WAEjBa,EAAShF,EAAG8D,WAAW,IAGzB,IAAIH,EAAWC,MAAMC,KAAKmB,EAAOlB,YAC9BC,IAAI,SAAAC,GACH,OAAOxB,EAAYwB,EAAOvB,EAC5B,GACCgC,OAEH,GAAoB,SAAhBzE,EAAGmE,SAAqB,CAC1B,IAAMc,EAAS9C,EAAI,UAAW,CAAElC,KAAM,IAAKyE,UAAW,KAAO,CAC3D,CAAEQ,KAAM,OAGV,OADAvB,EAASwB,QAAQF,GACV9C,EAAI,WAAY,CAAE,EAAEwB,EAC7B,CAEA,GAAI7D,EAAaqE,GAAW,CAC1B,GAAiB,QAAbA,EAAoB,CACtB,IAAMiB,EAAMpF,EAAGG,aAAa,OACxBsC,EAAU2C,KACZpF,EAAGiD,aAAa,MAAOR,EAAU2C,IACjCzB,EAAW,IAEb,IAAMD,EAAQ5D,EAAaqE,GAAUnE,GACrC,OAAOmC,EAAI,UAAWuB,EAAOC,EAC/B,CACA,GAAiB,OAAbQ,GAAkC,OAAbA,GAAkC,OAAbA,EAC5C,OAAOhC,EAAI,UAAW,CAAElC,KAAMkE,EAAUO,UAAWP,GAAYR,GAEjE,IAAMD,EAAQ5D,EAAaqE,GAAUnE,GACrC,OAAOmC,EAAI,UAAWuB,EAAOC,EAC/B,CAEA,GAAIvC,EAAU+C,GAAW,CACvB,IAAMT,EAAQtC,EAAU+C,GAAUnE,GAClC,OAAO2D,EAASI,IAAI,SAAAC,GAAK,OAAI7B,EAAI,OAAQuB,EAAOM,EAAM,EACxD,CAEA,OAAOL,CACT,CAgBA,OAAOnB,CAET,CD1HwB6C,CAAiBlD,GA8BrC,OA3BAD,EAAOK,eAAiB,SAAA+C,GACpB/C,EAAe+C,EACnB,EAEApD,EAAOG,SAAW,SAAAiD,GACd,MAAwB,SAAjBA,EAAQrF,MAAyBoC,EAASiD,EACrD,EAEApD,EAAOI,OAAS,SAAAgD,GACZ,MAAwB,UAAjBA,EAAQrF,MAA0BqC,EAAOgD,EACpD,EAEApD,EAAOE,WAAa,SAAAmD,GAChB,IAAMC,EAAOD,EAAKE,QAAQ,aAGpBhD,EFnBsB,SAACiD,EAAKF,GACxC,IAAMG,EAAM,GACNC,EAkE2B,SAAAJ,GAKjC,IAJA,IAEIK,EAFEC,EAAS,8BACTH,EAAM,GAGJE,EAAOC,EAAOC,KAAKP,IACzBG,EAAIxG,KAAK0G,EAAK,IAGhB,OAAOF,CACT,CA5EkBK,CAAoBR,GAC9BS,EAAe,GAEfC,EAyBe,SAAAC,GACrB,IAAMR,EAAM,GACNS,EAAkB,4FAClBC,EAAY,IAAIC,cACbF,EAAgBG,OACvB,yBAAA,KAEEC,EAAY,GAEVC,EAAcN,EAAWtD,MAAMwD,GACrC,IAAKI,EACH,OAAOd,EAGT,IAAK,IAAI5G,EAAI,EAAGA,EAAI0H,EAAYvH,OAAQH,IACtC,GAAIqH,EAAgBM,KAAKD,EAAY1H,IAAK,CACxC,IAA6C,IAAzC0H,EAAY1H,GAAG4H,QAAQ,aACzBH,EAAY,gBACHC,KAA0C,IAA1CA,EAAY1H,GAAG4H,QAAQ,cAGhC,SAFAH,EAAY,YAGd,CAEAb,EAAIxG,KAAK,CACPyH,IAAKJ,EACDC,EAAY1H,GACXsF,QAAQ+B,EAAiB,IACzB/B,QAAQ,eAAgB,IACzB,KACJpE,KAAMuG,GAEV,CAGF,OAAOb,CACT,CA7DoBkB,CAAenB,GACjC,GAAyB,IAArBQ,EAAUhH,OAAd,CAIA,IAAK,IAAIH,EAAI,EAAGA,EAAImH,EAAUhH,OAAQH,IAAK,CACzC,IAAMQ,EAkFDD,EAAqBT,EAlFeqH,EAAUnH,GAkFG6H,MAjFhDE,EAAOC,EAASC,mBAAmBzH,GAEnCW,GADS+G,OAAOC,KAAOD,OAAOE,WACjBC,gBAAgBN,GACnCb,EAAa9G,KAAKe,EACpB,CAEA,GAAI0F,EAAQ1G,SAAW+G,EAAa/G,OAClC,IAAK,IAAIH,EAAI,EAAGA,EAAI6G,EAAQ1G,OAAQH,IAEI,IAAlC6G,EAAQ7G,GAAG4H,QAAQ,YAAoBV,EAAalH,KACtD4G,EAAIC,EAAQ7G,IAAMkH,EAAalH,IAKrC,OAAO4G,CAnBP,CAoBF,CET0B0B,CAFN9B,EAAKE,QAAQ,YAEmBD,GAE5C,GAAIA,EAAJ,CACI,IAAM8B,GAAc,IAAIC,WAAYC,gBAAgBhC,EAAM,aACpDiC,EAAWjF,EAAY8E,EAAYI,KAAMjF,GAC/CP,EAAOK,eAAekF,EAEzB,MAEDrF,EAAWmD,EACf,EACOrD,CACX"}