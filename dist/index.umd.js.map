{"version":3,"file":"index.umd.js","sources":["../src/utils.js","../src/native.js","../src/index.ts","../src/module.js"],"sourcesContent":["import * as blobUtil from 'blob-util'\n\n// Receives rtf and html data\n// Returns dictionary object of original img[src]:imgBlob\n// We must read the data from the rtf because the browser is not allowed to render pasted images using simply the src from your clipboard\nexport const imagePastingListener = (rtf, html) => {\n  const ret = {}\n  const imgTags = extractTagsFromHtml(html)\n  const newSrcValues = []\n\n  const hexImages = extractFromRtf(rtf)\n  if (hexImages.length === 0) {\n    return\n  }\n\n  for (let i = 0; i < hexImages.length; i++) {\n    const base64string = createSrcWithBase64(hexImages[i])\n    const blob = blobUtil.base64StringToBlob(base64string)\n    const URLObj = window.URL || window.webkitURL\n    const url = URLObj.createObjectURL(blob)\n    newSrcValues.push(url)\n  }\n\n  if (imgTags.length === newSrcValues.length) {\n    for (let i = 0; i < imgTags.length; i++) {\n      // Replace only `file` urls of images ( shapes get newSrcValue with null ).\n      if (imgTags[i].indexOf('file://') === 0 && newSrcValues[i]) {\n        ret[imgTags[i]] = newSrcValues[i]\n      }\n    }\n  }\n\n  return ret\n}\n\nconst extractFromRtf = rtfContent => {\n  const ret = []\n  const rePictureHeader = /\\{\\\\pict[\\s\\S]+?\\\\bliptag\\-?\\d+(\\\\blipupi\\-?\\d+)?(\\{\\\\\\*\\\\blipuid\\s?[\\da-fA-F]+)?[\\s\\}]*?/\n  const rePicture = new RegExp(\n    `(?:(${rePictureHeader.source}))([\\\\da-fA-F\\\\s]+)\\\\}`,\n    'g'\n  )\n  let imageType = ''\n\n  const wholeImages = rtfContent.match(rePicture)\n  if (!wholeImages) {\n    return ret\n  }\n\n  for (let i = 0; i < wholeImages.length; i++) {\n    if (rePictureHeader.test(wholeImages[i])) {\n      if (wholeImages[i].indexOf('\\\\pngblip') !== -1) {\n        imageType = 'image/png'\n      } else if (wholeImages[i].indexOf('\\\\jpegblip') !== -1) {\n        imageType = 'image/jpeg'\n      } else {\n        continue\n      }\n\n      ret.push({\n        hex: imageType\n          ? wholeImages[i]\n            .replace(rePictureHeader, '')\n            .replace(/[^\\da-fA-F]/g, '')\n          : null,\n        type: imageType,\n      })\n    }\n  }\n\n  return ret\n}\n\nexport const extractTagsFromHtml = html => {\n  const regexp = /<img[^>]+src=\"([^\"]+)[^>]+/g\n  const ret = []\n  let item\n\n  while ((item = regexp.exec(html))) {\n    ret.push(item[1])\n  }\n\n  return ret\n}\n\nconst convertHexStringToBytes = hexString => {\n  const bytesArray = []\n  const bytesArrayLength = hexString.length / 2\n  let i\n\n  for (i = 0; i < bytesArrayLength; i++) {\n    bytesArray.push(parseInt(hexString.substr(i * 2, 2), 16))\n  }\n  return bytesArray\n}\n\nfunction createSrcWithBase64(img) {\n  const ret = null\n  return convertBytesToBase64(convertHexStringToBytes(img.hex))\n}\n\nconst convertBytesToBase64 = bytesArray => {\n  // Bytes are `8bit` numbers, where base64 use `6bit` to store data. That's why we process 3 Bytes into 4 characters representing base64.\n  //\n  // Algorithm:\n  // 1. Take `3 * 8bit`.\n  // 2. If there is less than 3 bytes, fill empty bits with zeros.\n  // 3. Transform `3 * 8bit` into `4 * 6bit` numbers.\n  // 4. Translate those numbers to proper characters related to base64.\n  // 5. If extra zero bytes were added fill them with `=` sign.\n  //\n  // Example:\n  // 1. Bytes Array: [ 8, 161, 29, 138, 218, 43 ] -> binary: `0000 1000 1010 0001 0001 1101 1000 1010 1101 1010 0010 1011`.\n  // 2. Binary: `0000 10|00 1010| 0001 00|01 1101| 1000 10|10 1101| 1010 00|10 1011` ← `|` (pipe) shows where base64 will cut bits during transformation.\n  // 3. Now we have 6bit numbers (written in decimal values), which are translated to indexes in `base64characters` array.\n  //    Decimal: `2 10 4 29 34 45 40 43` → base64: `CKEditor`.\n  const base64characters =\n    'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\n  let base64string = ''\n  const bytesArrayLength = bytesArray.length\n  let i\n\n  for (i = 0; i < bytesArrayLength; i += 3) {\n    const array3 = bytesArray.slice(i, i + 3)\n    const array3length = array3.length\n    const array4 = []\n\n    if (array3length < 3) {\n      for (let j = array3length; j < 3; j++) {\n        array3[j] = 0\n      }\n    }\n\n    // 0xFC -> 11111100 || 0x03 -> 00000011 || 0x0F -> 00001111 || 0xC0 -> 11000000 || 0x3F -> 00111111\n    array4[0] = (array3[0] & 0xfc) >> 2\n    array4[1] = ((array3[0] & 0x03) << 4) | (array3[1] >> 4)\n    array4[2] = ((array3[1] & 0x0f) << 2) | ((array3[2] & 0xc0) >> 6)\n    array4[3] = array3[2] & 0x3f\n\n    for (let j = 0; j < 4; j++) {\n      // Example: if array3length == 1, then we need to add 2 equal signs at the end of base64.\n      // array3[ 0 ] is used to calculate array4[ 0 ] and array4[ 1 ], so there will be regular values,\n      // next two ones have to be replaced with `=`, because array3[ 1 ] and array3[ 2 ] wasn't present in the input string.\n      if (j <= array3length) {\n        base64string += base64characters.charAt(array4[j])\n      } else {\n        base64string += '='\n      }\n    }\n  }\n  return base64string\n}\n","// Element and Text Tags Definitions\n\nexport const ELEMENT_TAGS = {\n  A: el => ({ type: 'link', url: el.getAttribute('href') }),\n  BLOCKQUOTE: () => ({ type: 'quote' }),\n  H1: () => ({ type: 'heading-one' }),\n  H2: () => ({ type: 'heading-two' }),\n  H3: () => ({ type: 'heading-three' }),\n  H4: () => ({ type: 'heading-four' }),\n  H5: () => ({ type: 'heading-five' }),\n  H6: () => ({ type: 'heading-six' }),\n  IMG: el => ({ type: 'image', url: el.getAttribute('src') }),\n  LI: el => ({ type: 'list-item' }),\n  OL: () => ({ type: 'numbered-list' }),\n  P: () => ({ type: 'paragraph' }),\n  PRE: () => ({ type: 'code' }),\n  UL: () => ({ type: 'bulleted-list' }),\n  TABLE: () => ({ type: 'table' }),\n  TR: () => ({ type: 'table-row' }),\n  TD: () => ({ type: 'table-cell' }),\n}\n\nexport const TEXT_TAGS = {\n  CODE: () => ({ code: true }),\n  DEL: () => ({ strikethrough: true }),\n  EM: () => ({ italic: true }),\n  I: () => ({ italic: true }),\n  S: () => ({ strikethrough: true }),\n  B: () => ({ bold: true }),\n  U: () => ({ underline: true }),\n}\n","import { imagePastingListener } from './utils';\nimport { makeDeserializer } from './module';\n\nimport './styles.css';\n\nexport const withDocxDeserializer = (editor, jsx) => {\n    const { insertData, isInline, isVoid, insertFragment } = editor\n    const deserialize = makeDeserializer(jsx)\n\n\n    editor.insertFragment = element => {\n        insertFragment(element)\n    }\n\n    editor.isInline = element => {\n        return element.type === 'link' ? true : isInline(element)\n    }\n\n    editor.isVoid = element => {\n        return element.type === 'image' ? true : isVoid(element)\n    }\n\n    editor.insertData = data => {\n        const html = data.getData('text/html')\n        const rtf = data.getData('text/rtf')\n        // image tags have to be cleaned out and converted\n        const imageTags = imagePastingListener(rtf, html)\n\n        if (html) {\n            const parsed_html = new DOMParser().parseFromString(html, 'text/html')\n            const fragment = deserialize(parsed_html.body, imageTags)\n            editor.insertFragment(fragment)\n            return\n        }\n\n        insertData(data)\n    }\n    return editor\n}\n","import { ELEMENT_TAGS, TEXT_TAGS } from './native'\n\nexport const makeDeserializer = (jsx) => {\n  const deserialize = (el, imageTags) => {\n    if (\n      el.attributes &&\n      el.attributes.getNamedItem('class') &&\n      el.attributes.getNamedItem('class').value.match(/done/g)\n    ) {\n      return null\n    }\n\n    if (isList(el)) {\n      return deserializeList(el, imageTags)\n    }\n    return deserializeElement(el, imageTags)\n  }\n\n  function deserializeList(el, imageTags) {\n    const siblings = getSiblings(el)\n    const type = 'UL'\n    const list_wrapper = document.createElement(type)\n    for (let i = 0; i < siblings.length; i++) {\n      list_wrapper.appendChild(siblings[i])\n    }\n\n    const attrs = ELEMENT_TAGS[type](list_wrapper)\n    const children = Array.from(list_wrapper.childNodes)\n      .map(child => {\n        return deserializeListItem(child, imageTags)\n      })\n      .flat()\n\n    return jsx('element', attrs, children)\n  }\n  function deserializeElement(el, imageTags) {\n    if (el.nodeType === 3) {\n      if (el.parentNode.nodeName === 'O:P') {\n        if (el.parentNode.parentNode.nodeName === 'P') {\n          return el.textContent\n        }\n      }\n\n      if (el.textContent.match(/^[\\s]*$/gm)) {\n        return null\n      } else {\n        // sometimes work adds line breaks when pasting\n        const regex = /\\n(?!\\n)/g\n        el.textContent = el.textContent.replace(regex, ' ')\n        return el.textContent\n      }\n    } else if (el.nodeType !== 1) {\n      return null\n    } else if (el.nodeName === 'BR') {\n      return '\\n'\n    }\n\n    const { nodeName } = el\n\n    let parent = el\n\n    if (\n      nodeName === 'PRE' &&\n      el.childNodes[0] &&\n      el.childNodes[0].nodeName === 'CODE'\n    ) {\n      parent = el.childNodes[0]\n    }\n\n    let children = Array.from(parent.childNodes)\n      .map(child => {\n        return deserialize(child, imageTags)\n      })\n      .flat()\n\n    if (el.nodeName === 'BODY') {\n      const filler = jsx('element', { type: 'p', className: 'P' }, [\n        { text: ' ' },\n      ])\n      children.unshift(filler)\n      return jsx('fragment', {}, children)\n    }\n\n    if (ELEMENT_TAGS[nodeName]) {\n      if (nodeName === 'IMG') {\n        const src = el.getAttribute('src')\n        if (imageTags[src]) {\n          el.setAttribute('src', imageTags[src])\n          children = []\n        }\n        const attrs = ELEMENT_TAGS[nodeName](el)\n        return jsx('element', attrs, children)\n      }\n      if (nodeName === 'H3' || nodeName === 'H2' || nodeName === 'H1') {\n        return jsx('element', { type: nodeName, className: nodeName }, children)\n      }\n      const attrs = ELEMENT_TAGS[nodeName](el)\n      return jsx('element', attrs, children)\n    }\n\n    if (TEXT_TAGS[nodeName]) {\n      const attrs = TEXT_TAGS[nodeName](el)\n      return children.map(child => jsx('text', attrs, child))\n    }\n\n    return children\n  }\n\n  function deserializeListItem(el, imageTags) {\n    const level = el.getAttribute('style')\n    const content = getTextfromList(el)\n      .map(c => {\n        return deserializeElement(c, imageTags)\n      })\n      .flat()\n    return jsx(\n      'element',\n      { type: 'list-item', className: 'level'.concat(level) },\n      content\n    )\n  }\n\n  return deserialize\n\n}\n\n\n\n// gets ALL the\nfunction getSiblings(el) {\n  // const level = el.attributes.getNamedItem('style').value.match(/level(\\d+)/)[1]\n  const siblings = []\n  while (\n    el &&\n    el.attributes.getNamedItem('class') &&\n    el.attributes.getNamedItem('class').value.match(/MsoListParagraph/g)\n  ) {\n    const level = el.attributes\n      .getNamedItem('style')\n      .value.match(/level(\\d+)/)[1]\n    el.setAttribute('class', 'done') // we set this attribute to avoid getting stuck in an infinite loop\n    el.setAttribute('style', level)\n    siblings.push(el)\n    el = el.nextElementSibling\n  }\n\n  return siblings\n}\n\n// Docx lists begin with \"MsoListParagraph\".\nfunction isList(el) {\n  if (\n    el.attributes &&\n    el.attributes.getNamedItem('class') &&\n    el.attributes.getNamedItem('class').value.match(/MsoListParagraph/g)\n  ) {\n    return true\n  }\n  return false\n}\n\n// Future functionality: Ordered Lists\nfunction isOrderedList(el) {\n  const val = el.textContent[0]\n  const regex = /^\\d+$/\n  if (regex.test(val)) {\n    return true\n  }\n  return false\n}\n\n\n// receives a list item and returns the text inside it\n// sometimes the text will be inside a text tag or inside a span tag.\n// when it is inside a text tag, the span is irrelevant, but it contains empty text inside\nfunction getTextfromList(el) {\n  const children = Array.from(el.childNodes)\n  const result = []\n  children.map(child => {\n    if (TEXT_TAGS[child.nodeName] || child.nodeName === '#text') {\n      result.push(child)\n    } else if (child.nodeName === 'SPAN') {\n      child.textContent = child.textContent.replace(\n        /(^(\\W)(?=\\s)*)|(o\\s)(?!\\w)/gm,\n        ''\n      )\n      result.push(child)\n    }\n  })\n  return result\n}\n"],"names":["convertHexStringToBytes","hexString","i","bytesArray","bytesArrayLength","length","push","parseInt","substr","convertBytesToBase64","base64string","array3","slice","array3length","array4","j","charAt","ELEMENT_TAGS","A","el","type","url","getAttribute","BLOCKQUOTE","H1","H2","H3","H4","H5","H6","IMG","LI","OL","P","PRE","UL","TABLE","TR","TD","TEXT_TAGS","CODE","code","DEL","strikethrough","EM","italic","I","S","B","bold","U","underline","editor","jsx","insertData","isInline","isVoid","insertFragment","deserialize","imageTags","attributes","getNamedItem","value","match","isList","siblings","level","setAttribute","nextElementSibling","getSiblings","list_wrapper","document","createElement","appendChild","attrs","children","Array","from","childNodes","map","child","content","result","nodeName","textContent","replace","getTextfromList","c","deserializeElement","flat","className","concat","deserializeListItem","deserializeList","nodeType","parentNode","parent","filler","text","unshift","src","makeDeserializer","element","data","html","getData","rtf","ret","imgTags","item","regexp","exec","extractTagsFromHtml","newSrcValues","hexImages","rtfContent","rePictureHeader","rePicture","RegExp","source","imageType","wholeImages","test","indexOf","hex","extractFromRtf","blob","blobUtil","base64StringToBlob","window","URL","webkitURL","createObjectURL","imagePastingListener","parsed_html","DOMParser","parseFromString","fragment","body"],"mappings":"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"}